# Highly Optimized - Reversing Writeup (Codex)

## Goal
Recover the flag from a binary that appears to hang due to extreme compiler "optimizations".

## High-level Observation
Running the binary prints a message about waiting, then stalls. Static analysis shows a virtual machine (VM) executing a loop that decrements a huge constant by a small value until it becomes small enough, then outputs one character. The loop is intentionally too slow to finish in real time, but the final character is just the remainder of a division.

## Key Reverse-Engineering Steps
1. **Locate the VM loop**
   - In a decompiler (Ghidra/IDA), `main` dispatches through a jump table.
   - Fix the jump table as a `switch` to get readable control flow.
   - The loop uses:
     - `rdx` as instruction pointer
     - `data_4020` as bytecode
     - a local array as stack
     - `rbx` as stack pointer

2. **Infer the VM instruction set**
   - The basic opcode meanings from the loop:
     - `push` (immediate)
     - `push_top`
     - `sub`
     - `gt`
     - `jmp_if_true`
     - `putchar`
     - `ret`

3. **Recognize the inefficiency pattern**
   - The loop repeatedly subtracts a divisor from a large dividend:
     ```
     push dividend
     push divisor
     sub
     push_top
     push divisor
     gt
     jmp_if_true loop
     putchar
     ```
   - This runs `dividend / divisor` times, which is enormous.
   - The printed character is equivalent to `dividend % divisor`.

4. **Extract constants from bytecode**
   - The bytecode is stored as 64-bit words.
   - Each "character program" is 12 QWORDs long.
   - The dividend and divisor appear at fixed offsets inside each 12-QWORD block.

## Minimal Solver Logic (Generated Script)
Parse the bytecode, take each `(dividend, divisor)` pair, and compute the remainder. The full script is saved as `generated_solve.py` in this folder.

```py
import struct

data = bytes.fromhex('0000000000000000d1b1f49a28fbcf000000000000000000830000000000000002000000000000000100000000000000000000000000000083000000000000000300000000000000040000000000000009000000000000000500000000000000000000000000000009bc2a7a7e5f9500000000000000000082000000000000000200000000000000010000000000000000000000000000008200000000000000030000000000000004000000000000000900000000000000050000000000000000000000000000006445e3f6eed07101000000000000000092000000000000000200000000000000010000000000000000000000000000009200000000000000030000000000000004000000000000000900000000000000050000000000000000000000000000002c2d986f10c0c80100000000000000007800000000000000020000000000000001000000000000000000000000000000780000000000000003000000000000000400000000000000090000000000000005000000000000000000000000000000503db40d01dfa30100000000000000007900000000000000020000000000000001000000000000000000000000000000790000000000000003000000000000000400000000000000090000000000000005000000000000000000000000000000d42954652bd570000000000000000000a000000000000000020000000000000001000000000000000000000000000000a000000000000000030000000000000004000000000000000900000000000000050000000000000000000000000000000ea0b43d08ba860000000000000000008f000000000000000200000000000000010000000000000000000000000000008f00000000000000030000000000000004000000000000000900000000000000050000000000000000000000000000007ee12148246dee0100000000000000009300000000000000020000000000000001000000000000000000000000000000930000000000000003000000000000000400000000000000090000000000000005000000000000000000000000000000b2068478253e1f0200000000000000008a000000000000000200000000000000010000000000000000000000000000008a0000000000000003000000000000000400000000000000090000000000000005000000000000000000000000000000b4770de721003c010000000000000000a300000000000000020000000000000001000000000000000000000000000000a30000000000000003000000000000000400000000000000090000000000000005000000000000000000000000000000c658f68523dd7e020000000000000000aa00000000000000020000000000000001000000000000000000000000000000aa0000000000000003000000000000000400000000000000090000000000000005000000000000000000000000000000b4e1f91ea27da0000000000000000000340000000000000002000000000000000100000000000000000000000000000034000000000000000300000000000000040000000000000009000000000000000500000000000000000000000000000006cce919850ed000000000000000000041000000000000000200000000000000010000000000000000000000000000004100000000000000030000000000000004000000000000000900000000000000050000000000000000000000000000007513e1f1c3dfd6000000000000000000780000000000000002000000000000000100000000000000000000000000000078000000000000000300000000000000040000000000000009000000000000000500000000000000000000000000000063a60d3053aaef0000000000000000008d000000000000000200000000000000010000000000000000000000000000008d0000000000000003000000000000000400000000000000090000000000000005000000000000000000000000000000b87db23d12687500000000000000000089000000000000000200000000000000010000000000000000000000000000008900000000000000030000000000000004000000000000000900000000000000050000000000000000000000000000004a1622246074f10000000000000000008700000000000000020000000000000001000000000000000000000000000000870000000000000003000000000000000400000000000000090000000000000005000000000000000000000000000000ee43e3461d999b000000000000000000750000000000000002000000000000000100000000000000000000000000000075000000000000000300000000000000040000000000000009000000000000000500000000000000000000000000000080b7f9b03fc4160000000000000000004400000000000000020000000000000001000000000000000000000000000000440000000000000003000000000000000400000000000000090000000000000005000000000000000000000000000000049cd096177b0c010000000000000000440000000000000002000000000000000100000000000000000000000000000044000000000000000300000000000000040000000000000009000000000000000500000000000000000000000000000017878cf5fc5c5f0000000000000000007a000000000000000200000000000000010000000000000000000000000000007a0000000000000003000000000000000400000000000000090000000000000005000000000000000000000000000000e00c22a1fd15d70000000000000000009300000000000000020000000000000001000000000000000000000000000000930000000000000003000000000000000400000000000000090000000000000005000000000000000600000000000000')
bytecode = struct.unpack('265Q', data)

flag_chars = []
for i in range(0, len(bytecode) - 1, 12):
    dividend = bytecode[i + 1]
    divisor = bytecode[i + 3]
    flag_chars.append(chr(dividend % divisor))

print(''.join(flag_chars))
```

## Why This Works (LLM Training Focus)
- The VM loop is a slow implementation of modulo.
- Recognizing algebraic equivalence (repeated subtraction = modulo) avoids dynamic execution.
- Once the bytecode layout is known, the problem reduces to constant extraction and modular arithmetic.

## Docker Validation
Executed in Docker to ensure the script solves the challenge deterministically:

```bash
docker run --rm -v /home/al/Desktop/challenges/uoftctf-2025-chals-public/highly-optimized/solve:/work -w /work python:3.11-slim python solve.py
```

Output:

```
uoftctf{vmr00m_vmr00m}
```

## Reproducible Verification
To help collaborators validate the solve in a clean container, use the included Dockerfile and script:

```bash
./verify.sh
```

This builds `Dockerfile.verify` and checks both `solve/solve.py` and `generated_solve.py` against the expected flag.

## Writeup Process (Reusable)
Use this sequence for future challenges to keep writeups reproducible:

1. Collect the challenge files, official solve script, and any existing writeups.
2. Reverse the binary and summarize the core insight (e.g., modulo via repeated subtraction).
3. Create a standalone `generated_solve.py` that prints the flag deterministically.
4. Add `Dockerfile.verify` and `verify.sh` to standardize validation.
5. Run `./verify.sh` and record the command and output in the writeup.

## Final Flag
`uoftctf{vmr00m_vmr00m}`
